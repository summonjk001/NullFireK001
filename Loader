local 默认值 = {
	ESP = {
		["钱袋ESP"] = false,
		["怪兽ESP"] = false,
		["死亡怪兽ESP"] = false,
		["动物ESP"] = false,
		["死亡动物ESP"] = false,
		["物品ESP"] = false,
		["保险箱密码ESP"] = false,
		["火车(最有用)ESP"] = false
	},
	额外提示距离 = 1,
	自动收集钱袋 = false,
	自动拾取工具 = false,
	自动拾取其他 = false,
	自动拾取护甲 = false,
	自动拾取债券 = false,
	无碰撞 = false,
	正常相机 = false,
	显示时间 = false,
	显示距离 = false,
	显示速度 = false,
	显示燃料 = false,
	即时交互 = false,
	枪杀光环 = false,
	近战光环 = false,
	自动重载枪支 = false,
	射线检测 = false,
	无声瞄准 = false,
	模式 = "距离",
	无虚空 = false,
	节省子弹 = false,

	绷带使用 = 0,
	蛇油使用 = 0,
	蛇油使用冷却 = 5,
	杀光环范围 = 500,

	投掷力量 = 100
}

local 值 = table.clone(默认值)
值.ESP = table.clone(默认值.ESP)

local function 获取全局表()
	return typeof(getfenv().getgenv) == "function" and typeof(getfenv().getgenv()) == "table" and getfenv().getgenv() or _G
end

获取全局表().火中心已加载 = true

local 库 = loadstring(game:HttpGet("https://raw.githubusercontent.com/InfernusScripts/Null-Fire/main/Core/Libraries/Fire-Lib/Main.lua", true))()
local ESP库 = loadstring(game:HttpGet("https://raw.githubusercontent.com/InfernusScripts/Null-Fire/main/Core/Libraries/ESP/Main.lua", true))()
local 侧边文本 = loadstring(game:HttpGet("https://raw.githubusercontent.com/InfernusScripts/Null-Fire/main/Core/Libraries/Side-Text/Main.lua", true))()
local 玩家 = game:GetService("Players").LocalPlayer

if game.PlaceId == 116495829188952 then
	return 库.通知:通知({标题 = "嘿！", 文本 = "请在游戏中加载脚本！"})
end

ESP库.值 = 值.ESP

local function 渲染步进(次数)
	local 次数 = math.max(math.round(tonumber(次数) or 1), 1)
	local 时间差 = 0
	for i=1, 次数 do
		时间差 = 时间差 + game:GetService("RunService").RenderStepped:Wait()
	end
	return 时间差 / 次数
end

local function 渲染等待(时间)
	local 开始 = tick()
	时间 = tonumber(时间) or 0
	
	渲染步进()
	task.wait(时间 / 2)
	渲染步进()
	task.wait(时间 / 2)
	渲染步进()
	
	return tick() - 开始
end

local ESP功能 = ESP库.应用ESP

local 已关闭 = false
local 连接 = {}
local 提示 = {}
local 原始提示 = {}
local 钩子 = {}

local 冷却 = {}
local 触发近距离提示 = false
local 触发近距离提示函数 = getfenv().fireproximityprompt

local 可能已死亡 = {}
local 死亡弹药 = {}

local function 是否死亡(人形)
	if 可能已死亡[人形] then
		return true
	end

	if 人形 and 人形.Parent then
		if not 人形:IsA("Humanoid") then
			人形 = 人形:FindFirstChild("Humanoid")
		end

		if 人形 then
			if 可能已死亡[人形] then
				return true
			end

			local 已死亡 = 人形.Health <= 0.01 and 人形.PlatformStand
			if 已死亡 then
				可能已死亡[人形] = true
			end

			return 已死亡
		end
	end

	return true
end

local 我的枪支 = {}
local 近战武器 = {}
local 治疗物品 = {
	绷带 = {},
	["蛇油"] = {}
}

local function 检查背包(物品)
	if 物品 and 物品:IsA("Tool") then
		if 物品:FindFirstChild("WeaponConfiguration") and not 我的枪支[物品] then
			我的枪支[物品] = true
		elseif 物品:FindFirstChild("SwingEvent") and not 近战武器[物品] then
			近战武器[物品] = true
		elseif 治疗物品[物品.Name] and not 治疗物品[物品.Name][物品] then
			治疗物品[物品.Name][物品] = true
		end
	end
end

local 工具元表 = setmetatable({}, {
	__index = function(self, 值)
		if 值 == "GetChildren" then
			local 工具 = 玩家.Backpack:GetChildren()

			if 玩家.Character then
				for i,v in 玩家.Character:GetChildren() do
					if v and v:IsA("Tool") then
						table.insert(工具, 1, v)
					end
				end
			end

			return 工具
		end
		if 玩家 and 玩家.Character and 玩家.Character:FindFirstChildOfClass("Tool") and 玩家.Character:FindFirstChildOfClass("Tool").Name == 值 then
			return 玩家.Character:FindFirstChildOfClass("Tool")
		end
		return 玩家.Backpack:FindFirstChild(值)
	end
})

for i,v in 工具元表.GetChildren do
	检查背包(v)
end
连接[#连接+1] = 玩家.Backpack.ChildAdded:Connect(检查背包)

local 冷却时间 = {}
local function 设置冷却(枪)
	冷却时间[枪] = true
	task.wait((枪.WeaponConfiguration.FireDelay.Value * 1.5) + 0.25)
	冷却时间[枪] = false
end

local function 添加功能(表, 值)
	if 值 == nil or typeof(表) ~= "table" then return end
	local 索引 = 1
	while true do
		if 值 == nil or typeof(值) == "Instance" and 值.Parent == nil then
			return -1
		end
		if 表[索引] == nil or typeof(表[索引]) == "Instance" and 表[索引].Parent == nil then
			表[索引] = 值
			return 索引
		end
		索引 = 索引 + 1
	end
end
local function 添加(表, 值)
	task.spawn(添加功能, 表, 值)
end
local function 移除(表, 值)
	task.spawn(pcall, table.remove, 表, table.find(表, 值))
end
local function 计数(表)
	local 数量 = 0
	for i,v in 表 do
		if typeof(v) == "Instance" and v.Parent ~= nil or typeof(v) ~= "Instance" and v ~= nil then
			数量 = 数量 + 1
		end
	end
	return 数量
end
local function 获取第一个(表)
	for v,i in 表 do
		if typeof(v) == "Instance" and (v.Parent == 玩家.Character or v.Parent == 玩家.Backpack) or typeof(v) ~= "Instance" and v ~= nil then
			return v
		else
			移除(表, v)
		end
	end
end

local function 融合表(表1, 表2)
	for i,v in 表2 do
		添加(表1, v)
	end

	return 表1
end

local function 射线投射(起点, 终点, 忽略)
	local 射线参数 = RaycastParams.new()

	射线参数.IgnoreWater = true
	射线参数.FilterDescendantsInstances = 融合表(玩家.Character and 玩家.Character:GetDescendants() or {}, 忽略 or {})

	local 结果 = workspace:Raycast(起点, (终点 - 起点).Unit * (终点 - 起点).Magnitude, 射线参数)
	return 结果 and 结果.Instance
end

local 射击 = game:GetService("ReplicatedStorage").Remotes.Weapon.Shoot
local 重载 = game:GetService("ReplicatedStorage").Remotes.Weapon.Reload
local function 开枪(枪, 目标)
	if not 是否死亡(目标) and (值.射线检测 and not 射线投射(workspace.CurrentCamera.CFrame.Position, 目标:GetPivot().Position, 目标:GetDescendants()) or not 值.射线检测) and (workspace.CurrentCamera.CFrame.Position - 目标:GetPivot().Position).Magnitude <= 值.杀光环范围 then
		local 头部 = 目标:FindFirstChild("Head") or 目标:GetPivot()

		local 命中 = {}
		for i=1, 枪.WeaponConfiguration.PelletsPerBullet.Value do
			命中[tostring(i)] = 目标.Humanoid
		end

		if 目标.Humanoid.Health - 枪.WeaponConfiguration.BulletDamage.Value < 0 and 枪.ServerWeaponState.CurrentAmmo.Value >= 1 and not 冷却时间[枪] then
			死亡弹药[目标.Humanoid] = (tonumber(死亡弹药[目标.Humanoid]) or 3) - 1
			if 死亡弹药[目标.Humanoid] <= 0 then
				可能已死亡[目标.Humanoid] = true
			end
			task.spawn(设置冷却, 枪)
		end

		射击:FireServer(workspace:GetServerTimeNow(), 枪, CFrame.lookAt(头部.Position + (头部.CFrame.LookVector * 10), 头部.Position), 命中)
	end
end
local function 重载枪支(枪)
	重载:FireServer(workspace:GetServerTimeNow(), 枪)
end

if 触发近距离提示函数 then
	pcall(function()
		task.spawn(function()
			local 提示 = Instance.new("ProximityPrompt", workspace)
			local 连接; 连接 = 提示.Triggered:Connect(function()
				连接:Disconnect()
				触发近距离提示 = true
				task.wait(0.1)
				提示.Parent = nil
				task.wait(0.1)
				提示:Destroy()
			end)
			task.wait(0.1)
			触发近距离提示函数(提示)
			task.wait(1.5)
			if 提示 and 提示.Parent then
				连接:Disconnect()
				task.wait(0.1)
				提示.Parent = nil
				task.wait(0.1)
				提示:Destroy()
			end
		end)
	end)
end

local function 触发提示功能(提示)
	冷却[提示] = true
	local a,b,c,d,e = 提示.MaxActivationDistance, 提示.Enabled, 提示.Parent, 提示.HoldDuration, 提示.RequiresLineOfSight
	local 对象 = Instance.new("Part", workspace)
	对象.Transparency = 1
	对象.CanCollide = false
	对象.Size = Vector3.new(0.1, 0.1, 0.1)
	对象.Anchored = true
	提示.Parent = 对象
	提示.MaxActivationDistance = math.huge
	提示.Enabled = true
	提示.HoldDuration = 0
	提示.RequiresLineOfSight = false
	if not 提示 or not 提示.Parent then
		对象:Destroy()
		return
	end
	对象:PivotTo(workspace.CurrentCamera.CFrame + (workspace.CurrentCamera.CFrame.LookVector / 5))
	渲染步进()
	对象:PivotTo(workspace.CurrentCamera.CFrame + (workspace.CurrentCamera.CFrame.LookVector / 5))
	渲染步进()
	对象:PivotTo(workspace.CurrentCamera.CFrame + (workspace.CurrentCamera.CFrame.LookVector / 5))
	提示:InputHoldBegin()
	渲染步进()
	提示:InputHoldEnd()
	渲染步进()
	if 提示.Parent == 对象 then
		提示.Parent = c
		提示.MaxActivationDistance = a
		提示.Enabled = b
		提示.HoldDuration = d
		提示.RequiresLineOfSight = e
	end
	对象:Destroy()
	冷却[提示] = false
end
local function 可获取中心点(提示)
	return 提示.Parent.GetPivot
end
local 触发近距离提示 = function(提示, 立即)
	if not 立即 and (typeof(提示) ~= "Instance" or not 提示:IsA("ProximityPrompt") or not pcall(可获取中心点, 提示) or 冷却[提示] or not workspace.CurrentCamera or ((game.Players.LocalPlayer and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer.Character.HumanoidRootPart or workspace.CurrentCamera).CFrame.Position - 提示.Parent:GetPivot().Position).Magnitude > 提示.MaxActivationDistance * 2) then return end
	if 触发近距离提示 then
		return 触发近距离提示函数(提示)
	end
	task.spawn(触发提示功能, 提示)
end

local function 插入空格(字符串)
	local 新字符串 = 字符串:gsub("(%u)", " %1")
	if 新字符串:sub(1, 1) == " " then
		新字符串 = 新字符串:sub(2)
	end

	return 新字符串:gsub("  ", " "):gsub("_", "") .. ""
end

local function 获取选中对象()
	return game:GetService("ReplicatedStorage").Client.Handlers.DraggableItemHandlers.ClientDraggableObjectHandler.DragHighlight.Adornee
end

local function 投掷对象(对象)
	if (对象:GetPivot().Position - 玩家.Character:GetPivot().Position).Magnitude > 20 then
		return
	end

	game:GetService("ReplicatedStorage").Shared.Remotes.RequestStartDrag:FireServer(对象)

	local 父级

	while true do
		local 拖拽1 = 对象:FindFirstChild("DragAttachment", math.huge)
		local 拖拽2 = 对象:FindFirstChild("DragAlignPosition", math.huge)
		local 拖拽3 = 对象:FindFirstChild("DragAlignOrientation", math.huge)

		if not 拖拽1 and not 拖拽2 and not 拖拽3 and 父级 then
			break
		end

		if 拖拽1 then
			父级 = 拖拽1.Parent
			拖拽1:Destroy()
			continue
		end
		if 拖拽2 then
			父级 = 拖拽2.Parent
			拖拽2:Destroy()
			continue
		end
		if 拖拽3 then
			父级 = 拖拽3.Parent
			拖拽3:Destroy()
			continue
		end

		task.wait()
	end

	task.wait()

	if 父级 then
		父级.AssemblyLinearVelocity = CFrame.lookAt(workspace.CurrentCamera.CFrame.Position, 父级:GetPivot().Position + Vector3.new(0, ((10000 - 值.投掷力量)/10000) * 5 - 0.25)).LookVector * 值.投掷力量
		task.wait()
	end

	game:GetService("ReplicatedStorage").Shared.Remotes.RequestStopDrag:FireServer()
end

local function 投掷()
	local 对象 = 获取选中对象()
	if not 对象 then
		return 库.通知:通知({标题 = "无对象", 文本 = "请看向你想投掷的对象！"})
	end

	投掷对象(对象)
end

local ESP表 = {}
local 死亡ESP表 = {}
local 怪兽 = {}

local 工具 = {}
local 债券 = {}
local 其他 = {}
local 可装备 = {}

local 可拾取 = { "消耗品", "枪", "武器", "近战", "可玩", "工具" }
local 护甲 = { "可装备" }

local 信息存储 = {}

local function 获取信息(对象)
	渲染等待()
	
	if not 对象 or not 对象.Parent then return end
	if 信息存储[对象.Name] then return 信息存储[对象.Name] end

	local 信息 = {}
	for i,v in 对象:WaitForChild("ObjectInfo", 9e9):GetChildren() do
		if v.Name ~= "Title" and v:IsA("TextLabel") then
			添加(信息, v.Text)
        end
	end

	信息存储[对象.Name] = 信息
	return 信息
end

local function 有属性(对象, 属性)
	if not 对象:FindFirstChild("ObjectInfo") then return false end

	local 信息 = 获取信息(对象)

	if not 信息 then return false end

	for i,v in 信息 do
		if v == 属性 then
			return true
		end
	end

	return false
end

local function 获取颜色(物品)
	local 值 = 物品 and 物品:GetAttribute("Value")
	if 物品.Name == "Bond" then
		return Color3.fromRGB(255, 170)
	elseif 物品.Name == "Coal" then
		return Color3.new(0.2, 0.2, 0.2)
	elseif 物品.Name == "Bandage" then
		return Color3.fromRGB(255, 150, 255)
	elseif 物品.Name == "Snake Oil" then
		return Color3.fromRGB(0, 170)
	elseif 有属性(物品, "Ammo") then
		return Color3.fromRGB(255, 170, 125)
	elseif 有属性(物品, "Weapon") or 有属性(物品, "Gun") or 有属性(物品, "Melee") then
		return Color3.new(0.75, 0.5, 0.5)
	elseif 值 then
		if 值 <= 50 then
			return Color3.new(0.8, 0.8, 0.8):Lerp(Color3.fromRGB(255, 255, 75), 值 / 50)
		elseif 值 <= 175 then
			return Color3.fromRGB(255, 255, 75):Lerp(Color3.fromRGB(75, 255, 255), (值 - 50) / 175)
		else
			return Color3.fromRGB(75, 255, 255):Lerp(Color3.fromRGB(255, 125, 255), (值 - 175) / 325)
		end
	end
	return Color3.new(0.8, 0.8, 0.8)
end

local function 获取文本(对象)
	local 名称 = 对象.Name
	local 小写名称 = 名称:lower()
	
	if 小写名称:match("vase") then
		return "花瓶"
	elseif 小写名称:match("outlaw") then
		return "歹徒"
	elseif 小写名称:match("zombie") then
		return "僵尸"
	elseif 小写名称:match("nikola") then
		return "天哪，这是那个混蛋"
	end
	
	return 插入空格(名称)
end

local function 主函数(物品)
	渲染等待()
	
	if 物品 and 物品.Parent then
		if 物品:IsA("ProximityPrompt") and not 原始提示[物品] then
			原始提示[物品] = 物品.MaxActivationDistance
			物品.MaxActivationDistance *= 值.额外提示距离
		elseif 物品:IsA("Model") and not game:GetService("Players"):GetPlayerFromCharacter(物品) then
			if 物品.Name ~= "Moneybag" and 物品.Name ~= "Vault" then
				if 物品:GetAttribute("DangerScore") or 物品.Parent and (物品.Parent.Name:lower():match("enemies") or 物品.Parent.Name:lower():match("enemy")) then
					local 人形 = 物品:WaitForChild("Humanoid", 9e9)

					local 怪兽数据 = ESP表[物品.Name] or {高亮启用 = false, 颜色 = Color3.new(0.35):Lerp(Color3.new(1), (物品:GetAttribute("DangerScore") or 10) / 100), 文本 = 获取文本(物品), ESP名称 = "怪兽ESP"}
					ESP表[物品.Name] = 怪兽数据

					ESP功能(物品, 怪兽数据)
					添加(怪兽, 物品)

					repeat task.wait() until not 人形 or not 人形.Parent or 是否死亡(人形)

					pcall(ESP库.取消应用ESP, 物品)

					local 死亡数据 = 死亡ESP表[物品.Name] or {高亮启用 = true, 颜色 = Color3.fromRGB(200, 150, 50):Lerp(Color3.fromRGB(255, 75, 0), (物品:GetAttribute("DangerScore") / 10) / 100), 文本 = 获取文本(物品), ESP名称 = "死亡怪兽ESP"}
					死亡ESP表[物品.Name] = 死亡数据

					ESP功能(物品, 死亡数据)

					return
				end

				if 物品:GetAttribute("BloodColor") then
					local 人形 = 物品:WaitForChild("Humanoid", 9e9)

					local 动物数据 = ESP表[物品.Name] or {高亮启用 = true, 颜色 = 获取颜色(物品), 文本 = 获取文本(物品) .. (物品:GetAttribute("Value") and " (" .. 物品:GetAttribute("Value") .. "$)" or ""), ESP名称 = "动物ESP"}
					ESP表[物品.Name] = 动物数据

					ESP功能(物品, 动物数据)

					repeat task.wait() until not 人形 or not 人形.Parent or 是否死亡(人形)

					pcall(ESP库.取消应用ESP, 物品)

					local 死亡数据 = 死亡ESP表[物品.Name] or {高亮启用 = true, 颜色 = Color3.new(1, 0.7, 0.7), 文本 = 获取文本(物品) .. (物品:GetAttribute("Value") and " (" .. 物品:GetAttribute("Value") .. "$)" or ""), ESP名称 = "死亡动物ESP"}
					死亡ESP表[物品.Name] = 死亡数据

					ESP功能(物品, 死亡数据)

					return
				end

				if 物品:FindFirstChild("ObjectInfo") and (物品:FindFirstChild("Base") and 物品.Base:IsA("BasePart") and not 物品.Base.Anchored or not 物品:FindFirstChild("Base") or not 物品.Base:IsA("BasePart")) then
					local 工具数据 = ESP表[物品.Name] or {高亮启用 = false, 颜色 = 获取颜色(物品), 文本 = 获取文本(物品) .. (物品:GetAttribute("Value") and " (" .. 物品:GetAttribute("Value") .. "$)" or ""), ESP名称 = "物品ESP"}

					ESP表[物品.Name] = 工具数据

					ESP功能(物品, 工具数据)

					for i,va in 可拾取 do
						if 有属性(物品, va) then
							添加(工具, 物品)
							return
						end
					end
					
					if 物品:GetAttribute("ActivateText") then
						return 添加(其他, 物品)
					end

					for i,va in 护甲 do
						if 有属性(物品, va) then
							添加(可装备, 物品)
							return
						end
					end
					
					if 有属性(物品, "Currency") then
						添加(债券, 物品)
						return
					end
				end
			elseif 物品.Name == "Moneybag" then
				local 价格 = tonumber(物品:WaitForChild("MoneyBag", 9e9):WaitForChild("BillboardGui", 9e9):WaitForChild("TextLabel", 9e9).Text:gsub("%$", "") .. "")
				local 钱袋数据 = ESP表[价格] or {高亮启用 = true, 颜色 = Color3.fromRGB(85, 170, 0), 文本 = 价格 .. "$", ESP名称 = "钱袋ESP"}

				ESP表[价格] = 钱袋数据

				ESP功能(物品, 钱袋数据)
				添加(提示, 物品.MoneyBag:WaitForChild("CollectPrompt", 9e9))
			elseif 物品.Name == "Vault" and 物品:FindFirstChild("Combination") then
				ESP功能(物品, {高亮启用 = true, 颜色 = Color3.fromRGB(85, 170, 0), 文本 = "[" .. tostring(物品.Combination.Value):gsub("", " ") .. "]", ESP名称 = "保险箱密码ESP"})
			end
		end
	end
end

local 获取最近怪兽; 获取最近怪兽 = function(模式)
	模式 = 模式 or 值.模式
	if 模式 == "角度" and workspace.CurrentCamera then
		local 角度, 距离, 怪 = math.huge, math.huge, nil
		for i,v in 怪兽 do
			if v and v.Parent and not 是否死亡(v) then
				if 值.射线检测 and 射线投射(workspace.CurrentCamera.CFrame.Position, v.GetPivot(v).Position, v.GetDescendants(v)) then
					continue
				end

				local 距离值 = (玩家.Character.GetPivot(玩家.Character).Position - v.GetPivot(v).Position).Magnitude
				local 角度值 = ((workspace.CurrentCamera.CFrame.Position + (workspace.CurrentCamera.CFrame.LookVector * 距离值)) - v.GetPivot(v).Position).Magnitude

				if 角度值 <= 角度 then
					距离 = 距离值
					角度 = 角度值
					怪 = v
				end
			end
		end

		return 怪, 距离
	elseif 模式 == "随机" then
		local 允许怪兽 = {}
		for i,v in 怪兽 do
			if v and v.Parent and not 是否死亡(v) then
				if 值.射线检测 and 射线投射(workspace.CurrentCamera.CFrame.Position, v.GetPivot(v).Position, v.GetDescendants(v)) then
					continue
				end

				添加(允许怪兽, v)
			end
		end

		if #允许怪兽 > 0 then
			local 怪兽 = 允许怪兽[math.random(1, #允许怪兽)]
			return 怪兽, 怪兽 and (玩家.Character.GetPivot(玩家.Character).Position - 怪兽.GetPivot(怪兽).Position).Magnitude
		end
		
		return 获取最近怪兽("角度")
	else
		local 距离, 怪 = math.huge, nil
		for i,v in 怪兽 do
			if v and v.Parent and not 是否死亡(v) then
				if 值.射线检测 and 射线投射(workspace.CurrentCamera.CFrame.Position, v.GetPivot(v).Position, v.GetDescendants(v)) then
					continue
				end

				local 距离值 = (玩家.Character.GetPivot(玩家.Character).Position - v.GetPivot(v).Position).Magnitude

				if 距离值 <= 距离 then
					距离 = 距离值
					怪 = v
				end
			end
		end

		return 怪, 距离
	end
end

local 获取名称调用方法, 钩子元方法 = getfenv().getnamecallmethod, getfenv().hookmetamethod
if 钩子元方法 and 获取名称调用方法 then
	local 旧方法; 旧方法 = 钩子元方法(game, "__namecall", function(self, ...)
		if 值.无声瞄准 and self == 射击 and 获取名称调用方法() == "FireServer" then
			local 参数 = { ... }

			local 怪, 距离 = 获取最近怪兽()

			if 怪 then
				local 命中 = {}
				for i=1, 参数[2].WeaponConfiguration.PelletsPerBullet.Value do
					命中[tostring(i)] = 怪.Humanoid
				end

				local 头部 = 怪:FindFirstChild("Head") or 怪:GetPivot()

				参数[3] = CFrame.lookAt(头部.Position + Vector3.new(0, 1), 头部.Position)
				参数[4] = 命中
			elseif 值.节省子弹 then
				参数[2].ClientWeaponState.CurrentAmmo.Value += 1
				error("取消射击", 0)
			end

			if 距离 <= 值.杀光环范围 then
				return 射击.FireServer(射击, unpack(参数))
			end
		elseif 值.节省子弹 and self == 射击 and 获取名称调用方法() == "FireServer" and not 获取最近怪兽() then
			({ ... })[2].ClientWeaponState.CurrentAmmo.Value += 1
			error("取消射击", 0)
		end

		return 旧方法(self, ...)
	end)

	钩子[#钩子 + 1] = function()
		钩子元方法(game, "__namecall", 旧方法)
	end
end

task.spawn(function()
	while not 已关闭 and task.wait(0.5) do
		if 值.枪杀光环 and 玩家.Character then
			local 怪, 距离 = 获取最近怪兽()
			if 怪 and 距离 <= 值.杀光环范围 then
				for v in 我的枪支 do
					if v and v.Parent and v:FindFirstChild("WeaponConfiguration") then
						pcall(开枪, v, 怪)
					end
				end
			end
		end
	end
end)
task.spawn(function()
	while not 已关闭 and task.wait(0.5) do
		if 值.自动重载枪支 and 玩家.Character then
			for v in 我的枪支 do
				if v and v.Parent and v:FindFirstChild("WeaponConfiguration") then
					pcall(重载枪支, v)
				end
			end
		end
	end
end)

local 攻击距离 = 30
local 远距离事件 = {}

local function 装备直到无僵尸(工具, 僵尸)
	工具.Parent = 玩家.Character

	if not 远距离事件[僵尸] then
		远距离事件[僵尸] = Instance.new("BindableEvent")
		repeat task.wait() until not 值.近战光环 or 是否死亡(僵尸)

		远距离事件[僵尸]:Fire()

		远距离事件[僵尸]:Destroy()
		远距离事件[僵尸] = nil
	else
		远距离事件[僵尸].Event:Wait()
	end

	工具.Parent = 玩家.Backpack
end

task.spawn(function()
	while not 已关闭 and task.wait(0.1) do
		if 值.近战光环 and 玩家.Character then
			local 怪, 距离 = 获取最近怪兽("距离")
			if 怪 and 距离 <= 攻击距离 then
				for v in 近战武器 do
					if v and v.Parent and v:FindFirstChild("SwingEvent") then
						if v.Parent == 玩家.Backpack then
							task.spawn(装备直到无僵尸, v, 怪)
						end

						v.SwingEvent:FireServer(CFrame.lookAt(玩家.Character:GetPivot().Position, 怪:GetPivot().Position + Vector3.new(0, 2)).LookVector)
					end
				end
			end
		end
	end
end)

for i,v in workspace:GetDescendants() do
	task.spawn(主函数, v)
end
连接[#连接+1] = workspace.DescendantAdded:Connect(主函数)

local 虚空 = pcall(function()
	workspace.FallenPartsDestroyHeight = workspace.FallenPartsDestroyHeight
end)

local 蛇油冷却 = false
连接[#连接+1] = game:GetService("RunService").RenderStepped:Connect(function()
	侧边文本("清除文本")
	if workspace.Train.TrainControls:FindFirstChild("TimeDial") then
		if 值.显示时间 then
			侧边文本("更新行", "左", "时间: " .. workspace.Train.TrainControls.TimeDial.SurfaceGui.TextLabel.Text)
		end
		if 值.显示距离 then
			侧边文本("更新行", "左", "已行驶: " .. workspace.Train.TrainControls.DistanceDial.SurfaceGui.TextLabel.Text)
		end
		if 值.显示速度 then
			侧边文本("更新行", "左", "速度: " .. (math.round((workspace.Train.TrainControls.Spedometer.SurfaceGui.ImageLabel.Gauge.Rotation - 120) / 163 * 65 * 10) / 10) .. " 单位/秒")
		end
		if 值.显示燃料 then
			侧边文本("更新行", "左", "燃料: " .. (math.round((workspace.Train.TrainControls.Fuel.SurfaceGui.ImageLabel.Gauge.Rotation - 120) / 300 * 1000) / 10) .. "%")
		end
	end
	if 值.全亮 then
		game.Lighting.Ambient = Color3.new(1, 1, 1)
		game.Lighting.Brightness = 1.5
	end
	if 值.正常相机 then
		玩家.CameraMode = Enum.CameraMode.Classic
	end
	if 虚空 then
		workspace.FallenPartsDestroyHeight = 值.无虚空 and 0/0 or -500
	end
	玩家.DevCameraOcclusionMode = 值.正常相机 and Enum.DevCameraOcclusionMode.Invisicam or Enum.DevCameraOcclusionMode.Invisicam or Enum.DevCameraOcclusionMode.Zoom
	game.Lighting.GlobalShadows = not 值.全亮
	if 值.自动收集钱袋 then
		for i,v in 提示 do
			if v and v.Parent then
				触发近距离提示(v)
			else
				移除(提示, v)
			end
		end
	end
	if 玩家.Character then
		if 值.无碰撞 then
			for i,v in 玩家.Character:GetDescendants() do
				if v and v:IsA("BasePart") then
					v.CanCollide = false
				end
			end
		elseif 玩家.Character:FindFirstChild("HumanoidRootPart") then
			玩家.Character.HumanoidRootPart.CanCollide = true
		end

		local 人形 = 玩家.Character:FindFirstChildOfClass("Humanoid")
		
		if not 人形 or 人形.Health <= 0.01 and 人形.PlatformStand then return end
		if 值.自动拾取工具 then
			for i,v in 工具 do
				if v and v.Parent then
					if (v:GetPivot().Position - 玩家.Character:GetPivot().Position).Magnitude <= 30 then
						game:GetService("ReplicatedStorage").Remotes.Tool.PickUpTool:FireServer(v)
					end
				else
					移除(提示, v)
				end
			end
		end
		if 值.自动拾取其他 then
			for i,v in 其他 do
				if v and v.Parent then
					if (v:GetPivot().Position - 玩家.Character:GetPivot().Position).Magnitude <= 30 then
						game:GetService("ReplicatedStorage").Packages.RemotePromise.Remotes.C_ActivateObject:FireServer(v)
					end
				else
					移除(提示, v)
				end
			end
		end
		if 值.自动拾取债券 then
			for i,v in 债券 do
				if v and v.Parent then
					if (v:GetPivot().Position - 玩家.Character:GetPivot().Position).Magnitude <= 30 then
						game:GetService("ReplicatedStorage").Packages.RemotePromise.Remotes.C_ActivateObject:FireServer(v)
					end
				else
					移除(提示, v)
				end
			end
		end
		if 值.自动拾取护甲 then
			for i,v in 可装备 do
				if v and v.Parent then
					if (v:GetPivot().Position - 玩家.Character:GetPivot().Position).Magnitude <= 30 then
						game:GetService("ReplicatedStorage").Remotes.Object.EquipObject:FireServer(v)
					end
				else
					移除(提示, v)
				end
			end
		end

		local 绷带 = 获取第一个(治疗物品.绷带)
		if 绷带 and 绷带.Parent and 玩家.Character:FindFirstChildOfClass("Humanoid").Health <= 值.绷带使用 then
			return 绷带.Use:FireServer(绷带)
		end

		local 蛇油 = 获取第一个(治疗物品["蛇油"])
		if not 蛇油冷却 and 蛇油 and 蛇油.Parent and 玩家.Character:FindFirstChildOfClass("Humanoid").Health <= 值.蛇油使用 then
			蛇油冷却 = true
			蛇油.Use:FireServer(蛇油)
			task.wait(值.蛇油使用冷却)
			蛇油冷却 = false
		end
	end
end)

连接[#连接+1] = game:GetService("ProximityPromptService").PromptButtonHoldBegan:Connect(function(提示)
	if 值.即时交互 then
		触发近距离提示(提示, true)
	end
end)

local 窗口 = 库:创建窗口({标题 = "NullFire: 死亡铁路", 关闭回调 = function()
	for i,v in 默认值 do
		值[i] = v
	end
	for i,v in 默认值.ESP do
		ESP库.ESP值[i] = v
	end
	for i,v in 钩子 do
		task.spawn(v)
	end
	for i,v in 原始提示 do
		if i and i.Parent and v then
			i.MaxActivationDistance = v
		end
	end
	获取全局表().火中心已加载 = false
	已关闭 = true
	
	渲染等待(0.1)
	
	for i,v in 连接 do
		v:Disconnect()
	end
end}, true)

local 页面 = 窗口:添加页面({标题 = "角色"})
页面:添加开关({标题 = "无碰撞", 默认 = false, 回调 = function(布尔值)
	值.无碰撞 = 布尔值
end})
if 虚空 then
	页面:添加分隔线()
	页面:添加开关({标题 = "无虚空 (修复掉落地图死亡)", 默认 = false, 回调 = function(布尔值)
		值.无虚空 = 布尔值
	end})
end

local 页面 = 窗口:添加页面({标题 = "交互"})
页面:添加开关({标题 = "自动拾取钱袋", 默认 = false, 回调 = function(布尔值)
	值.自动收集钱袋 = 布尔值
end})
页面:添加开关({标题 = "自动拾取工具", 默认 = false, 回调 = function(布尔值)
	值.自动拾取工具 = 布尔值
end})
页面:添加开关({标题 = "自动拾取护甲", 默认 = false, 回调 = function(布尔值)
	值.自动拾取护甲 = 布尔值
end})
页面:添加开关({标题 = "自动拾取债券", 默认 = false, 回调 = function(布尔值)
	值.自动拾取债券 = 布尔值
end})
页面:添加开关({标题 = "自动拾取弹药和其他", 默认 = false, 回调 = function(布尔值)
	值.自动拾取其他 = 布尔值
end})

页面:添加分隔线()
页面:添加开关({标题 = "即时交互", 默认 = false, 回调 = function(布尔值)
	值.即时交互 = 布尔值
end})
页面:添加滑块({标题 = "提示激活距离倍数", 默认 = 1, 最小 = 1, 最大 = 2, 步长 = 0.01, 回调 = function(倍数)
	值.额外提示距离 = 倍数
	for i,v in 原始提示 do
		if i and i.Parent and v then
			i.MaxActivationDistance = v * 倍数
		end
	end
end})

页面:添加分隔线()

页面:添加滑块({标题 = "当生命值低于时自动使用绷带:", 默认 = 0, 最小 = 0, 最大 = 99.5, 步长 = 0.5, 回调 = function(生命值)
	值.绷带使用 = 生命值
end})
页面:添加滑块({标题 = "当生命值低于时自动使用蛇油:", 默认 = 0, 最小 = 0, 最大 = 100, 步长 = 0.5, 回调 = function(生命值)
	值.蛇油使用 = 生命值
end})
页面:添加滑块({标题 = "自动使用蛇油冷却时间", 默认 = 5, 最小 = 0, 最大 = 10, 步长 = 0.1, 回调 = function(冷却时间)
	值.蛇油使用冷却 = 冷却时间
end})

local 页面 = 窗口:添加页面({标题 = "视觉"})

页面:添加开关({标题 = "显示距离", defaults = false, 回调 = function(布尔值)
	值.显示距离 = 布尔值
end})
页面:添加开关({标题 = "显示时间", 默认 = false, 回调 = function(布尔值)
	值.显示时间 = 布尔值
end})
页面:添加开关({标题 = "显示速度", 默认 = false, 回调 = function(布尔值)
	值.显示速度 = 布尔值
end})
页面:添加开关({标题 = "显示燃料", 默认 = false, 回调 = function(布尔值)
	值.显示燃料 = 布尔值
end})

页面:添加分隔线()

页面:添加开关({标题 = "全亮", 默认 = false, 回调 = function(布尔值)
	值.全亮 = 布尔值
end})
页面:添加开关({标题 = "正常相机", 默认 = false, 回调 = function(布尔值)
	值.正常相机 = 布尔值
	渲染步进(2)
	玩家.CameraMode = 值.正常相机 and Enum.CameraMode.Classic or Enum.CameraMode.LockFirstPerson
	if 布尔值 then
		库.通知:通知({标题 = "正常相机", 文本 = "现在你可以拉远你的相机"})
	end
end})

页面:添加分隔线()

local 已激活 = false
页面:添加开关({标题 = "RGB ESP (可能会导致FPS问题，小心！)", 默认 = false, 回调 = function(布尔值)
	if not 已激活 then 已激活 = true return end
	ESP库.ESP值.RGBESP = 布尔值
	if 布尔值 then
		库.通知:通知({标题 = "RGB ESP", 文本 = "当物体过多时可能会导致FPS问题！\n仅在你认为设备足够强大时使用"})
	end
end})

页面:添加分隔线()

for i,v in 值.ESP do
	页面:添加开关({标题 = i:gsub("ESP", " ESP"), 默认 = v, 回调 = function(布尔值)
		ESP库.ESP值[i] = 布尔值
	end})
end

local 页面 = 窗口:添加页面({标题 = "杀光环"})

页面:添加开关({标题 = "枪杀光环", 默认 = false, 回调 = function(布尔值)
	值.枪杀光环 = 布尔值
end})
页面:添加开关({标题 = "近战杀光环 (自动铲子)", 默认 = false, 回调 = function(布尔值)
	值.近战光环 = 布尔值
end})
页面:添加滑块({标题 = "枪杀光环范围", 默认 = 值.杀光环范围, 最小 = 10, 最大 = 3000, 步长 = 1, 回调 = function(范围)
	值.杀光环范围 = 范围 >= 2751 and 1488228 or 范围 >= 2501 and 2500 or 范围
end, 自定义文本显示 = function(值)
	return (tonumber(值) >= 2751 and "无限" or tonumber(值) >= 2501 and "2500" or 值) .. " 单位"
end})

页面:添加分隔线()

local 目标选择 = {"距离", "角度", "随机"}
页面:添加下拉菜单({文本 = "寻找最近目标的方式", 默认 = "距离", 选项 = 目标选择, 回调 = function(名称)
	值.模式 = 目标选择[名称]
end})

页面:添加分隔线()

页面:添加开关({标题 = "自动重载枪支", 默认 = false, 回调 = function(布尔值)
	值.自动重载枪支 = 布尔值
end})

if 钩子元方法 and 获取名称调用方法 then
	页面:添加分隔线()
	页面:添加开关({标题 = "无声瞄准", 默认 = false, 回调 = function(布尔值)
		值.无声瞄准 = 布尔值
	end})
	页面:添加标签({标题 = "如果无声瞄准不起作用，那么你的执行器有问题"})
	页面:添加分隔线()

	页面:添加开关({标题 = "节省子弹", 默认 = false, 回调 = function(布尔值)
		值.节省子弹 = 布尔值
	end})
	页面:添加标签({标题 = "最好不要启用 ^^^ 因为不稳定且无法杀死动物"})
	页面:添加标签({标题 = "节省子弹会在没有活僵尸时取消射击"})
	页面:添加分隔线()
end

local 页面 = 窗口:添加页面({标题 = "恶搞"})

页面:添加按钮({标题 = "投掷对象", 回调 = 投掷})
页面:添加滑块({标题 = "投掷力量", 默认 = 值.投掷力量, 最小 = 10, 最大 = 10000, 步长 = 1, 回调 = function(力量)
	值.投掷力量 = 力量
end})

local 投掷键 = Enum.KeyCode.X
页面:添加输入框({文本 = "投掷快捷键", 默认 = 投掷键.Name, 回调 = function(键码)
	投掷键 = 键码
end})

连接[#连接+1] = game:GetService("UserInputService").InputBegan:Connect(function(按键, 处理)
	if 处理 or 按键.KeyCode ~= 投掷键 then return end
	投掷()
end)

页面:添加标签({标题 = "试试投掷朋友的尸体 XD"})

页面:添加分隔线()

页面:添加按钮({标题 = "火车故障", 回调 = function()
	if workspace.Train.TrainControls.ConductorSeat:FindFirstChild("VehicleSeat") then
		local 旧位置 = 玩家.Character:GetPivot()
		玩家.Character:PivotTo(旧位置 + Vector3.new(0, 5))
		task.wait(0.02)
		玩家.Character:PivotTo(workspace.Train.TrainControls.ConductorSeat.VehicleSeat:GetPivot())
		task.wait(0.02)
		玩家.Character:PivotTo(旧位置)
	else
		库.通知:通知({标题 = "哎呀！", 文本 = "看起来火车离得太远了"})
	end
end})

ESP功能(workspace:WaitForChild("Train", 9e9), {高亮启用 = false, 颜色 = Color3.fromRGB(55, 65, 65), 文本 = "火车", ESP名称 = "火车(最有用)ESP"})
