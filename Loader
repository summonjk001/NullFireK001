local defaults = {
    ESP = {
        ["Money BagESP"] = false, -- 钱袋ESP
        ["MonsterESP"] = false, -- 怪兽ESP
        ["Dead MonsterESP"] = false, -- 死亡怪兽ESP
        ["AnimalESP"] = false, -- 动物ESP
        ["Dead AnimalESP"] = false, -- 死亡动物ESP
        ["ItemESP"] = false, -- 物品ESP
        ["Vault CodeESP"] = false, -- 保险库代码ESP
        ["Train (the most useful)ESP"] = false -- 火车（最有用）ESP
    },
    ExtraPP = 1,
    AutoCollectBags = false, -- 自动收集钱袋
    AutoPickTools = false, -- 自动拾取工具
    AutoPickOther = false, -- 自动拾取其他物品
    AutoPickArmor = false, -- 自动拾取护甲
    AutoPickBonds = false, -- 自动拾取债券
    Noclip = false, -- 无碰撞
    NC = false,
    ShowTime = false, -- 显示时间
    ShowDistance = false, -- 显示距离
    ShowSpeed = false, -- 显示速度
    ShowFuel = false, -- 显示燃料
    II = false,
    GKA = false,
    MA = false,
    ARG = false,
    Raycast = false, -- 射线检测
    SilentAim = false, -- 无声瞄准
    Mode = "Distance", -- 模式：距离
    NoVoid = false, -- 无虚空
    SaveBulltets = false, -- 保存子弹

    BandageUse = 0, -- 绷带使用
    OilUse = 0, -- 蛇油使用
    OilUseCooldown = 5, -- 蛇油使用冷却时间
    KAR = 500, -- 击杀范围

    ThrowPower = 100 -- 投掷力量
}

local vals = table.clone(defaults)
vals.ESP = table.clone(defaults.ESP)

local function getGlobalTable()
    return typeof(getfenv().getgenv) == "function" and typeof(getfenv().getgenv()) == "table" and getfenv().getgenv() or _G
end

getGlobalTable().FireHubLoaded = true

local lib = loadstring(game:HttpGet("https://raw.githubusercontent.com/InfernusScripts/Null-Fire/main/Core/Libraries/Fire-Lib/Main.lua", true))()
local espLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/InfernusScripts/Null-Fire/main/Core/Libraries/ESP/Main.lua", true))()
local txtf = loadstring(game:HttpGet("https://raw.githubusercontent.com/InfernusScripts/Null-Fire/main/Core/Libraries/Side-Text/Main.lua"))()
local plr = game:GetService("Players").LocalPlayer

if game.PlaceId == 116495829188952 then
    return lib.Notifications:Notification({Title = "嘿！", Text = "请在游戏中加载脚本！"})
end

espLib.Values = vals.ESP

local function rs(times)
    local times = math.max(math.round(tonumber(times) or 1), 1)
    local dt = 0
    for i=1, times do
        dt = dt + game:GetService("RunService").RenderStepped:Wait()
    end
    return dt / times
end

local function renderWait(t)
    local start = tick()
    t = tonumber(t) or 0
    
    rs()
    task.wait(t / 2)
    rs()
    task.wait(t / 2)
    rs()
    
    return tick() - start
end

local espFunc = espLib.ApplyESP

local closed = false
local cons = {}
local prompts = {}
local oprompts = {}
local hooks = {}

local cd = {}
local fppn = false
local fpp = getfenv().fireproximityprompt

local probablyDead = {}
local deathAmmo = {}

local function isDead(hum)
    if probablyDead[hum] then
        return true
    end

    if hum and hum.Parent then
        if not hum:IsA("Humanoid") then
            hum = hum:FindFirstChild("Humanoid")
        end

        if hum then
            if probablyDead[hum] then
                return true
            end

            local dead = hum.Health <= 0.01 and hum.PlatformStand
            if dead then
                probablyDead[hum] = true
            end

            return dead
        end
    end

    return true
end

local myGuns = {}
local melee = {}
local heals = {
    Bandage = {}, -- 绷带
    ["Snake Oil"] = {} -- 蛇油
}

local function bp(v)
    if v and v:IsA("Tool") then
        if v:FindFirstChild("WeaponConfiguration") and not myGuns[v] then
            myGuns[v] = true
        elseif v:FindFirstChild("SwingEvent") and not melee[v] then
            melee[v] = true
        elseif heals[v.Name] and not heals[v.Name][v] then
            heals[v.Name][v] = true
        end
    end
end

local toolsMt = setmetatable({}, {
    __index = function(self, value)
        if value == "GetChildren" then
            local tools = plr.Backpack:GetChildren()

            if plr.Character then
                for i,v in plr.Character:GetChildren() do
                    if v and v:IsA("Tool") then
                        table.insert(tools, 1, v)
                    end
                end
            end

            return tools
        end
        if plr and plr.Character and plr.Character:FindFirstChildOfClass("Tool") and plr.Character:FindFirstChildOfClass("Tool").Name == value then
            return plr.Character:FindFirstChildOfClass("Tool")
        end
        return plr.Backpack:FindFirstChild(value)
    end
})

for i,v in toolsMt.GetChildren do
    bp(v)
end
cons[#cons+1] = plr.Backpack.ChildAdded:Connect(bp)

local cooldown = {}
local function setCooldown(gun)
    cooldown[gun] = true
    task.wait((gun.WeaponConfiguration.FireDelay.Value * 1.5) + 0.25)
    cooldown[gun] = false
end

local function addFunction(t,v)
    if v == nil or typeof(t) ~= "table" then return end
    local i = 1
    while true do
        if v == nil or typeof(v) == "Instance" and v.Parent == nil then
            return -1
        end
        if t[i] == nil or typeof(t[i]) == "Instance" and t[i].Parent == nil then
            t[i] = v
            return i
        end
        i = i + 1
    end
end
local function add(t,v)
    task.spawn(addFunction, t, v)
end
local function remove(t,v)
    task.spawn(pcall, table.remove, t, table.find(t, v))
end
local function count(t)
    local amnt = 0
    for i,v in t do
        if typeof(v) == "Instance" and v.Parent ~= nil or typeof(v) ~= "Instance" and v ~= nil then
            amnt = amnt + 1
        end
    end
    return amnt
end
local function getFirst(t)
    for v,i in t do
        if typeof(v) == "Instance" and (v.Parent == plr.Character or v.Parent == plr.Backpack) or typeof(v) ~= "Instance" and v ~= nil then
            return v
        else
            remove(t, v)
        end
    end
end

local function fuseTables(t1, t2)
    for i,v in t2 do
        add(t1, v)
    end

    return t1
end

local function raycast(from, to, ignore)
    local raycastParams = RaycastParams.new()

    raycastParams.IgnoreWater = true
    raycastParams.FilterDescendantsInstances = fuseTables(plr.Character and plr.Character:GetDescendants() or {}, ignore or {})

    local result = workspace:Raycast(from, (to - from).Unit * (to - from).Magnitude, raycastParams)
    return result and result.Instance
end

local s = game:GetService("ReplicatedStorage").Remotes.Weapon.Shoot
local r = game:GetService("ReplicatedStorage").Remotes.Weapon.Reload
local function shoot(gun, target)
    if not isDead(target) and (vals.Raycast and not raycast(workspace.CurrentCamera.CFrame.Position, target:GetPivot().Position, target:GetDescendants()) or not vals.Raycast) and (workspace.CurrentCamera.CFrame.Position - target:GetPivot().Position).Magnitude <= vals.KAR then
        local head = target:FindFirstChild("Head") or target:GetPivot()

        local hits = {}
        for i=1, gun.WeaponConfiguration.PelletsPerBullet.Value do
            hits[tostring(i)] = target.Humanoid
        end

        if target.Humanoid.Health - gun.WeaponConfiguration.BulletDamage.Value < 0 and gun.ServerWeaponState.CurrentAmmo.Value >= 1 and not cooldown[gun] then
            deathAmmo[target.Humanoid] = (tonumber(deathAmmo[target.Humanoid]) or 3) - 1
            if deathAmmo[target.Humanoid] <= 0 then
                probablyDead[target.Humanoid] = true
            end
            task.spawn(setCooldown, gun)
        end

        s:FireServer(workspace:GetServerTimeNow(), gun, CFrame.lookAt(head.Position + (head.CFrame.LookVector * 10), head.Position), hits)
    end
end
local function reload(gun)
    r:FireServer(workspace:GetServerTimeNow(), gun)
end

if fpp then
    pcall(function()
        task.spawn(function()
            local pp = Instance.new("ProximityPrompt", workspace)
            local con; con = pp.Triggered:Connect(function()
                con:Disconnect()
                fppn = true
                task.wait(0.1)
                pp.Parent = nil
                task.wait(0.1)
                pp:Destroy()
            end)
            task.wait(0.1)
            fpp(pp)
            task.wait(1.5)
            if pp and pp.Parent then
                con:Disconnect()
                task.wait(0.1)
                pp.Parent = nil
                task.wait(0.1)
                pp:Destroy()
            end
        end)
    end)
end

local function fppFunc(pp)
    cd[pp] = true
    local a,b,c,d,e = pp.MaxActivationDistance, pp.Enabled, pp.Parent, pp.HoldDuration, pp.RequiresLineOfSight
    local obj = Instance.new("Part", workspace)
    obj.Transparency = 1
    obj.CanCollide = false
    obj.Size = Vector3.new(0.1, 0.1, 0.1)
    obj.Anchored = true
    pp.Parent = obj
    pp.MaxActivationDistance = math.huge
    pp.Enabled = true
    pp.HoldDuration = 0
    pp.RequiresLineOfSight = false
    if not pp or not pp.Parent then
        obj:Destroy()
        return
    end
    obj:PivotTo(workspace.CurrentCamera.CFrame + (workspace.CurrentCamera.CFrame.LookVector / 5))
    rs()
    obj:PivotTo(workspace.CurrentCamera.CFrame + (workspace.CurrentCamera.CFrame.LookVector / 5))
    rs()
    obj:PivotTo(workspace.CurrentCamera.CFrame + (workspace.CurrentCamera.CFrame.LookVector / 5))
    pp:InputHoldBegin()
    rs()
    pp:InputHoldEnd()
    rs()
    if pp.Parent == obj then
        pp.Parent = c
        pp.MaxActivationDistance = a
        pp.Enabled = b
        pp.HoldDuration = d
        pp.RequiresLineOfSight = e
    end
    obj:Destroy()
    cd[pp] = false
end
local function canGetPivot(pp)
    return pp.Parent.GetPivot
end
local fireproximityprompt = function(pp, i)
    if not i and (typeof(pp) ~= "Instance" or not pp:IsA("ProximityPrompt") or not pcall(canGetPivot, pp) or cd[pp] or not workspace.CurrentCamera or ((game.Players.LocalPlayer and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer.Character.HumanoidRootPart or workspace.CurrentCamera).CFrame.Position - pp.Parent:GetPivot().Position
