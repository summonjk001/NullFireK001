local defaults = {
    ESP = {
        ["钱袋ESP"] = false,
        ["怪兽ESP"] = false,
        ["死亡怪兽ESP"] = false,
        ["动物ESP"] = false,
        ["死亡动物ESP"] = false,
        ["物品ESP"] = false,
        ["保险库代码ESP"] = false,
        ["火车(最有用)ESP"] = false
    },
    ExtraPP = 1,
    AutoCollectBags = false,
    AutoPickTools = false,
    AutoPickOther = false,
    AutoPickArmor = false,
    AutoPickBonds = false,
    Noclip = false,
    NC = false,
    ShowTime = false,
    ShowDistance = false,
    ShowSpeed = false,
    ShowFuel = false,
    II = false,
    GKA = false,
    MA = false,
    ARG = false,
    Raycast = false,
    SilentAim = false,
    Mode = "距离",
    NoVoid = false,
    SaveBulltets = false,

    BandageUse = 0,
    OilUse = 0,
    OilUseCooldown = 5,
    KAR = 500,

    ThrowPower = 100
}

local vals = table.clone(defaults)
vals.ESP = table.clone(defaults.ESP)

local function getGlobalTable()
    return typeof(getfenv().getgenv) == "function" and typeof(getfenv().getgenv()) == "table" and getfenv().getgenv() or _G
end

getGlobalTable().FireHubLoaded = true

local lib = loadstring(game:HttpGet("https://raw.githubusercontent.com/InfernusScripts/Null-Fire/main/Core/Libraries/Fire-Lib/Main.lua", true))()
local espLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/InfernusScripts/Null-Fire/main/Core/Libraries/ESP/Main.lua", true))()
local txtf = loadstring(game:HttpGet("https://raw.githubusercontent.com/InfernusScripts/Null-Fire/main/Core/Libraries/Side-Text/Main.lua"))()
local plr = game:GetService("Players").LocalPlayer

if game.PlaceId == 116495829188952 then
    return lib.Notifications:Notification({Title = "嘿！", Text = "请在游戏中加载脚本！"})
end

espLib.Values = vals.ESP

local function rs(times)
    local times = math.max(math.round(tonumber(times) or 1), 1)
    local dt = 0
    for i=1, times do
        dt = dt + game:GetService("RunService").RenderStepped:Wait()
    end
    return dt / times
end

local function renderWait(t)
    local start = tick()
    t = tonumber(t) or 0
    
    rs()
    task.wait(t / 2)
    rs()
    task.wait(t / 2)
    rs()
    
    return tick() - start
end

local espFunc = espLib.ApplyESP

local closed = false
local cons = {}
local prompts = {}
local oprompts = {}
local hooks = {}

local cd = {}
local fppn = false
local fpp = getfenv().fireproximityprompt

local probablyDead = {}
local deathAmmo = {}

local function isDead(hum)
    if probablyDead[hum] then
        return true
    end

    if hum and hum.Parent then
        if not hum:IsA("Humanoid") then
            hum = hum:FindFirstChild("Humanoid")
        end

        if hum then
            if probablyDead[hum] then
                return true
            end

            local dead = hum.Health <= 0.01 and hum.PlatformStand
            if dead then
                probablyDead[hum] = true
            end

            return dead
        end
    end

    return true
end

local myGuns = {}
local melee = {}
local heals = {
    绷带 = {},
    ["蛇油"] = {}
}

local function bp(v)
    if v and v:IsA("Tool") then
        if v:FindFirstChild("WeaponConfiguration") and not myGuns[v] then
            myGuns[v] = true
        elseif v:FindFirstChild("SwingEvent") and not melee[v] then
            melee[v] = true
        elseif heals[v.Name] and not heals[v.Name][v] then
            heals[v.Name][v] = true
        end
    end
end

local toolsMt = setmetatable({}, {
    __index = function(self, value)
        if value == "GetChildren" then
            local tools = plr.Backpack:GetChildren()

            if plr.Character then
                for i,v in plr.Character:GetChildren() do
                    if v and v:IsA("Tool") then
                        table.insert(tools, 1, v)
                    end
                end
            end

            return tools
        end
        if plr and plr.Character and plr.Character:FindFirstChildOfClass("Tool") and plr.Character:FindFirstChildOfClass("Tool").Name == value then
            return plr.Character:FindFirstChildOfClass("Tool")
        end
        return plr.Backpack:FindFirstChild(value)
    end
})

for i,v in toolsMt.GetChildren do
    bp(v)
end
cons[#cons+1] = plr.Backpack.ChildAdded:Connect(bp)

local cooldown = {}
local function setCooldown(gun)
    cooldown[gun] = true
    task.wait((gun.WeaponConfiguration.FireDelay.Value * 1.5) + 0.25)
    cooldown[gun] = false
end

local function addFunction(t,v)
    if v == nil or typeof(t) ~= "table" then return end
    local i = 1
    while true do
        if v == nil or typeof(v) == "Instance" and v.Parent == nil then
            return -1
        end
        if t[i] == nil or typeof(t[i]) == "Instance" and t[i].Parent == nil then
            t[i] = v
            return i
        end
        i = i + 1
    end
end
local function add(t,v)
    task.spawn(addFunction, t, v)
end
local function remove(t,v)
    task.spawn(pcall, table.remove, t, table.find(t, v))
end
local function count(t)
    local amnt = 0
    for i,v in t do
        if typeof(v) == "Instance" and v.Parent ~= nil or typeof(v) ~= "Instance" and v ~= nil then
            amnt = amnt + 1
        end
    end
    return amnt
end
local function getFirst(t)
    for v,i in t do
        if typeof(v) == "Instance" and (v.Parent == plr.Character or v.Parent == plr.Backpack) or typeof(v) ~= "Instance" and v ~= nil then
            return v
        else
            remove(t, v)
        end
    end
end

local function fuseTables(t1, t2)
    for i,v in t2 do
        add(t1, v)
    end

    return t1
end

local function raycast(from, to, ignore)
    local raycastParams = RaycastParams.new()

    raycastParams.IgnoreWater = true
    raycastParams.FilterDescendantsInstances = fuseTables(plr.Character and plr.Character:GetDescendants() or {}, ignore or {})

    local result = workspace:Raycast(from, (to - from).Unit * (to - from).Magnitude, raycastParams)
    return result and result.Instance
end

local s = game:GetService("ReplicatedStorage").Remotes.Weapon.Shoot
local r = game:GetService("ReplicatedStorage").Remotes.Weapon.Reload
local function shoot(gun, target)
    if not isDead(target) and (vals.Raycast and not raycast(workspace.CurrentCamera.CFrame.Position, target:GetPivot().Position, target:GetDescendants()) or not vals.Raycast) and (workspace.CurrentCamera.CFrame.Position - target:GetPivot().Position).Magnitude <= vals.KAR then
        local head = target:FindFirstChild("Head") or target:GetPivot()

        local hits = {}
        for i=1, gun.WeaponConfiguration.PelletsPerBullet.Value do
            hits[tostring(i)] = target.Humanoid
        end

        if target.Humanoid.Health - gun.WeaponConfiguration.BulletDamage.Value < 0 and gun.ServerWeaponState.CurrentAmmo.Value >= 1 and not cooldown[gun] then
            deathAmmo[target.Humanoid] = (tonumber(deathAmmo[target.Humanoid]) or 3) - 1
            if deathAmmo[target.Humanoid] <= 0 then
                probablyDead[target.Humanoid] = true
            end
            task.spawn(setCooldown, gun)
        end

        s:FireServer(workspace:GetServerTimeNow(), gun, CFrame.lookAt(head.Position + (head.CFrame.LookVector * 10), head.Position), hits)
    end
end
local function reload(gun)
    r:FireServer(workspace:GetServerTimeNow(), gun)
end

if fpp then
    pcall(function()
        task.spawn(function()
            local pp = Instance.new("ProximityPrompt", workspace)
            local con; con = pp.Triggered:Connect(function()
                con:Disconnect()
                fppn = true
                task.wait(0.1)
                pp.Parent = nil
                task.wait(0.1)
                pp:Destroy()
            end)
            task.wait(0.1)
            fpp(pp)
            task.wait(1.5)
            if pp and pp.Parent then
                con:Disconnect()
                task.wait(0.1)
                pp.Parent = nil
                task.wait(0.1)
                pp:Destroy()
            end
        end)
    end)
end

local function fppFunc(pp)
    cd[pp] = true
    local a,b,c,d,e = pp.MaxActivationDistance, pp.Enabled, pp.Parent, pp.HoldDuration, pp.RequiresLineOfSight
    local obj = Instance.new("Part", workspace)
    obj.Transparency = 1
    obj.CanCollide = false
    obj.Size = Vector3.new(0.1, 0.1, 0.1)
    obj.Anchored = true
    pp.Parent = obj
    pp.MaxActivationDistance = math.huge
    pp.Enabled = true
    pp.HoldDuration = 0
    pp.RequiresLineOfSight = false
    if not pp or not pp.Parent then
        obj:Destroy()
        return
    end
    obj:PivotTo(workspace.CurrentCamera.CFrame + (workspace.CurrentCamera.CFrame.LookVector / 5))
    rs()
    obj:PivotTo(workspace.CurrentCamera.CFrame + (workspace.CurrentCamera.CFrame.LookVector / 5))
    rs()
    obj:PivotTo(workspace.CurrentCamera.CFrame + (workspace.CurrentCamera.CFrame.LookVector / 5))
    pp:InputHoldBegin()
    rs()
    pp:InputHoldEnd()
    rs()
    if pp.Parent == obj then
        pp.Parent = c
        pp.MaxActivationDistance = a
        pp.Enabled = b
        pp.HoldDuration = d
        pp.RequiresLineOfSight = e
    end
    obj:Destroy()
    cd[pp] = false
end
local function canGetPivot(pp)
    return pp.Parent.GetPivot
end
local fireproximityprompt = function(pp, i)
    if not i and (typeof(pp) ~= "Instance" or not pp:IsA("ProximityPrompt") or not pcall(canGetPivot, pp) or cd[pp] or not workspace.CurrentCamera or ((game.Players.LocalPlayer and game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and game.Players.LocalPlayer.Character.HumanoidRootPart or workspace.CurrentCamera).CFrame.Position - pp.Parent:GetPivot().Position).Magnitude > pp.MaxActivationDistance * 2) then return end
    if fppn then
        return fpp(pp)
    end
    task.spawn(fppFunc, pp)
end

local function insertCum(str)
    local new = str:gsub("(%u)", " %1")
    if new:sub(1, 1) == " " then
        new = new:sub(2)
    end

    return new:gsub("  ", " "):gsub("_", "") .. ""
end

local function insertCum(str)
    local new = str:gsub("(%u)", " %1")
    if new:sub(1, 1) == " " then
        new = new:sub(2)
    end

    return new:gsub("  ", " "):gsub("_", "") .. ""
end

local function getSelectedObject()
    return game:GetService("ReplicatedStorage").Client.Handlers.DraggableItemHandlers.ClientDraggableObjectHandler.DragHighlight.Adornee
end

local function throwObject(object)
    if (object:GetPivot().Position - plr.Character:GetPivot().Position).Magnitude > 20 then
        return
    end

    game:GetService("ReplicatedStorage").Shared.Remotes.RequestStartDrag:FireServer(object)

    local par

    while true do
        local drag1 = object:FindFirstChild("DragAttachment", math.huge)
        local drag2 = object:FindFirstChild("DragAlignPosition", math.huge)
        local drag3 = object:FindFirstChild("DragAlignOrientation", math.huge)

        if not drag1 and not drag2 and not drag3 and par then
            break
        end

        if drag1 then
            par = drag1.Parent
            drag1:Destroy()
            continue
        end
        if drag2 then
            par = drag2.Parent
            drag2:Destroy()
            continue
        end
        if drag3 then
            par = drag3.Parent
            drag3:Destroy()
            continue
        end

        task.wait()
    end

    task.wait()

    if par then
        par.AssemblyLinearVelocity = CFrame.lookAt(workspace.CurrentCamera.CFrame.Position, par:GetPivot().Position + Vector3.new(0, ((10000 - vals.ThrowPower) / 1000), 0)).LookVector * vals.ThrowPower
    end

    game:GetService("ReplicatedStorage").Shared.Remotes.RequestEndDrag:FireServer(object)
end

local function throw()
    local object = getSelectedObject()
    if object then
        throwObject(object)
    else
        lib.Notifications:Notification({Title = "哎呀！", Text = "请先选择一个物体！"})
    end
end

local window = lib:CreateWindow({Title = "火焰中心", Size = UDim2.new(0, 500, 0, 400)})

local page = window:AddPage({Title = "主要功能"})

for i,v in vals.ESP do
    page:AddToggle({Caption = insertCum(i), Default = v, Callback = function(b)
        vals.ESP[i] = b
    end})
end

page:AddSeparator()

page:AddToggle({Caption = "自动收集钱袋", Default = vals.AutoCollectBags, Callback = function(b)
    vals.AutoCollectBags = b
end})
page:AddToggle({Caption = "自动拾取工具", Default = vals.AutoPickTools, Callback = function(b)
    vals.AutoPickTools = b
end})
page:AddToggle({Caption = "自动拾取其他物品", Default = vals.AutoPickOther, Callback = function(b)
    vals.AutoPickOther = b
end})
page:AddToggle({Caption = "自动拾取护甲", Default = vals.AutoPickArmor, Callback = function(b)
    vals.AutoPickArmor = b
end})
page:AddToggle({Caption = "自动拾取债券", Default = vals.AutoPickBonds, Callback = function(b)
    vals.AutoPickBonds = b
end})

page:AddSeparator()

page:AddLabel({Caption = "因为不稳定+无法杀死动物，自动功能已被移除"})
page:AddLabel({Caption = "如果周围没有活着的僵尸，保存子弹将取消射击"})
page:AddSeparator()

local page = window:AddPage({Title = "恶搞功能"})

page:AddButton({Caption = "投掷物体", Callback = throw})
page:AddSlider({Caption = "投掷力量", Default = vals.ThrowPower, Min = 10, Max = 10000, Step = 1, Callback = function(b)
    vals.ThrowPower = b
end})

local throwKey = Enum.KeyCode.X
page:AddInput({Text = "投掷快捷键", Default = throwKey.Name, Callback = function(kc)
    throwKey = kc
end})

cons[#cons+1] = game:GetService("UserInputService").InputBegan:Connect(function(kk, a)
    if a or kk.KeyCode ~= throwKey then return end
    throw()
end)

page:AddLabel({Caption = "试着扔一个朋友的尸体 XD"})

page:AddSeparator()

page:AddButton({Caption = "火车故障", Callback = function()
    if workspace.Train.TrainControls.ConductorSeat:FindFirstChild("VehicleSeat") then
        local old = plr.Character:GetPivot()
        plr.Character:PivotTo(old + Vector3.new(0, 5))
        task.wait(0.02)
        plr.Character:PivotTo(workspace.Train.TrainControls.ConductorSeat.VehicleSeat:GetPivot())
        task.wait(0.02)
        plr.Character:PivotTo(old)
    else
        lib.Notifications:Notification({Title = "哎呀！", Text = "火车似乎离得太远了"})
    end
end})

espFunc(workspace:WaitForChild("Train", 9e9), {HighlightEnabled = false, Color = Color3.fromRGB(55, 65, 65), Text = "火车", ESPName = "火车(最有用)ESP"})
